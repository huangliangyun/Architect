#### 问题
+ 如何避免重复消费（幂等性问题）?
+ 如何保证消息不丢失？
+ 如何实现公平消费？
+ 如何获取消费结果？
+ 如何保证消息顺序性？



#### 答案

+ 如何避免重复消费（幂等性问题）?  
1、每次消费的时候去数据库查  
2、redis每次都set，是不会出现问题  
3、现在redis设置一个id，设置成功就可以消费  


+ 如何保证消息不丢失？  
生产者：使用消息确认机制，确保消息成功投递到 MQ ,默认开启了消息持久化机制，消息持久化成功才会应答成产者。  
消费者：使用手动 ACK 确认消息是否消费成功。  
MQ：将数据持久化到硬盘 Durable  
硬盘坏了，断电了：使用表记录生产者投递的消息，如果长期没有被消费，手动补偿。  


+ 如何实现公平消费？  
默认的传统队列是为均摊消费，存在不公平性；如果每个消费者速度不一样的情况下，均摊消费是不公平的，应该是能者多劳。  
在通道中只需要设置 basicQos 为 1 即可，表示 MQ 服务器每次只会给消费者推送1条消息必须手动ack 确认之后才会继续发送。  
channel.basicQos(1);  


+ 如何获取消费结果？  
客户端调用生产者接口投递消息到MQ，如何确定是否被消费成功？也就是保证幂等性？  
客户端->生产者->MQ->消费者->数据  
多线程投递消息到 MQ  
消费时插入数据库  
主动查询数据库  


+ 如何保证消息顺序性？  
顺序问题的背景：  
1）单个 Broker 的情况下，存放消息默认情况下是有序的，因为遵循队列的先进先出原则。  
2）如果投递的消息行为是一样的情况下，没有必要关注消息顺序性问题。  
3）Broker 是集群的情况下，消息存放到了不同的分区，如果生产者往同一个队列中存放消息行为不统一，存在消息顺序性问题。如 insert->update->delete 。  
4）生产者，消费者异步的情况下  
如何解决：  
对相同业务逻辑的消息设置相同的消息 key，存放到同一个 Broker 中  