#### 问题

+ 类的加载过程？
+ minor gc 运行的很频繁可能是什么原因引起的？
+ minor gc运行的很慢有可能是什么原因引起的？
+ 请谈谈OOM可能发生在哪，怎么查看，怎么调优？
+ 请问怎么判断哪些对象是可以删除的，可达是什么意思？
+ 请简单描述一下JVM分区都有哪些？
+ 垃圾收集机制？
+ 如何查看JVM堆和栈的使用情况？
+ 内存泄露和内存溢出的区别？
+ fullGC触发条件？
+ 解释一些内存分配担保机制？


#### 答案

+ 类的加载过程？  
类加载的过程为加载，连接，初始化，使用，卸载  
加载：将.class文件读取到磁盘，  
连接分为3步，验证，准备，解析，验证：验证字节码的准确性，准备：给静态变量分配内存，给予默认值，解析：  类装载器装入类所引用的其他类  
初始化：为类的静态变量赋予正确的值，执行静态代码块    


+ minor gc 运行的很频繁可能是什么原因引起的？  
1）产生了大多招生熄灭的对象导致需要频繁minor gc 。  
2）新生代空间设置的较小  


+ minor gc运行的很慢有可能是什么原因引起的？  
1）新生代空间设置的过大  
2）对象引用链长，可达性分析较长  
3）新生代survivor区设置的比较小，清理后剩余的对象不能装进去，需要移到老年代，造成性能开销大。  
4）内存分配担保失败，由minorGC转化为fullGC  
https://www.cnblogs.com/xiaoxi/p/6557473.html  
5）采用垃圾收集器效率较低，比如新生代使用serial收集器  


+ 请谈谈OOM可能发生在哪，怎么查看，怎么调优？  
	1）	除了程序计数器不会发生OOM之外，其他地方都会发生OOM  
	2）	Java堆内存溢出，一般由内存泄露或者堆的大小设置不当引起，对于内存泄露，需要通过visualJVM查找程序中内存泄露的代码，堆的大小可以通过-Xmx，-Xms修改。  
	3）	方法区溢出，一般出现于大量Class信息，或者采用反射等机制引起的，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。  
	4）	栈溢出，JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。  
	5）	设置JVM参数-XX:+HeapDumpOnOutOfMemoryError，设定当发生OOM时自动dump出堆信息。  


+ 请问怎么判断哪些对象是可以删除的，可达是什么意思？  
  一般有两种方法，一种是引用计数法，一种是可达性分析  
  引用计数法是说，当有一个地方被引用时，计数器就+1,引用失败时，计数器就-1，计数器为0的对象不能再被使用。  
  可达性分析是说，通过一系列的GCRoot作为起始点从这些节点开始向下搜索，搜索走过的路被称为引用链，当一个对象到GC Roots没有任何引用链相连的时候，则证明此对象是不可用的。否则，即是可达的。  
  在java语言中，可作为GC Roots的对象包括下面几种：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象和本地方法栈中JNI（一般说的Native方法）引用的对象。	  


+ 请简单描述一下JVM分区都有哪些？  
JVM内存区域可按线程共享和线程私有来分，线程共享的为方法区和堆，线程私有的为栈，本地方法栈，程序计数器。堆主要保存new出来的实例，几乎所有的对象都在堆上分配，方法区上存放类的的信息，字符串常量池等，Java8叫元空间，之前叫永久代。  
程序计数器用来存放下一条执行的指令，栈是Java执行方法的内存模型，一个线程对应一个栈，每个方法执行的时候都会创建一个栈帧，每个栈帧包括局部变量表，操作数，动态链接和出口，本地方法栈为JVM执行的native方法。  


+ 垃圾收集机制？  
我们判断一个对象是否可以被回收，有两种方法，一种是引用计数法，一种是可达性分析，引用计数法是说，当一个地方被引用时，计数器就+1，引用失败，计数器就-1，计数器为0的对象就会被回收。以一系列的GCRoot作为起始点，从这些点开始向下搜索，搜索走过的路被称为引用链，当一个对象到GCRoot没有任何相连额时候，则证明此对象是不可用的。  
可做为GCRoot的包括虚拟机栈中引用的对象，方法区中静态属性，常量引用的对象，本地方法栈JNI中引用的对象。    我们常见的垃圾回收算法有：标记清除法，复制算法，标记整理法，分代收集法。标记清除法分为两个阶段，标记阶段标记出所有需要回收的对象，清除阶段对标记的对象进行回收。缺点是清除效率低，清除之后会产生大量的碎片。复制算法是将内存分为两块，每次当时用完一块后，把存活的对象复制到另一块，然后把已经时用的内存清理掉。优点是简单高效，不用考虑碎片的情况，缺点是可使用的内存降为原来的一半。  
标记整理法，标记阶段和标记清除算法相同，标记之后不是清除对象，而是将存活的对象移到内存的一端，清除边界之外的对象。分代收集法，将内存划分为几块，新生代和老年代，新创建的对象一般在新生代中分配空间，新生代垃圾收集器回收几次之后依然存活的对象就会被移到老年代，大对象在新生代没有足够的连续内存可以创建时，也会直接在老年代创建。  
新生代回收频率很高，但是每次回收时间都很短，老年代回收频率很低，但是每次回收时间都很长。  
我们常见的垃圾收集器可以按新生代和老年代来分，新生代可以使用Serial，ParNew，Parallel Scavenge。  
Serial是单线程的，采用复制算法，收集时STW，ParNew是多线程+复制算法，收集时会STW，Parallel Scavenge是多线程+复制算法，收集时STW，不过它所关注的是一个可控制的吞吐量。  
老年代的垃圾收集器有Serial Old，Paraller Old，CMS，Serial Old采用的是单线程+标记整理法，Parallel old 采用的是多线程+标记整理法。CMS采用的是多线程+标记清除算法，获取最短的垃圾回收停顿时间，他的回收过程分为四个步骤，初始标记，并发标记，重新标记，并发清除。G1收集器是把内存划分为各个大小已知的内存区域，每一个区域1M到32M之间的一个2的次幂，JVM会尽量划分2048个左右，同等大小的region，这个数字可以手动调整，G1会根据堆的大小自动调整，在G1的实现中，年代是一个逻辑概念，具体体现在，一部分的region作为Eden，一部分为suvivor，还有old，G1会将region中50%大小的对象归类为Humongous，并放置在相应的region中 。逻辑上，Humongous region算是老年代的一部分。G1提供了两种垃圾回收模式，YoungGC和MIxedGC，两种都是STW的。
当所有eden region使用达到最大阈值并且无法申请内存时，会触发一次YoungGC，每次YoungGC都会回收所有的Eden和Survivor区，并且把存活对象复制到Old区和另一部分Survivor区。当越来越多的对象晋升到Old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合收集器，及mixedGC，除了回收一部分young region，还会回收一部分的old region,可以选择哪些old region进行收集，从而对垃圾回收的耗时进行控制。G1没有fullGC的概念，需要fullGC时，调用serialOldGC进行全堆扫描。G1收集器分为以下几个步骤  
1、初始标记：标记了从GCRoot开始直接可达的对象  
2、并发标记：从GCRoot开始对堆中的对象进行可达性分析，找出存活的对象  
3、最终标记：标记那些在并发阶段发生变化的对象，将被回收  
4、筛选回收：对各个region的回收价值和成本进行比较，根据用户期待的GC停顿时间指定回收计划，回收一部分region。  


+ 如何查看JVM堆和栈的使用情况？  
先通过jps查看Java进程  
jmap：打印内存映射 ，制作堆dump文件  
jstack 打印线程栈信息，制作线程dump文件  
https://www.cnblogs.com/z-sm/p/6745375.html  


+ 内存泄露和内存溢出的区别？  
+ fullGC触发条件？  
1、调用System.gc  
2、老年代空间不足  
3、空间分配担保失败  
4、方法区空间不足  
https://blog.csdn.net/lwl2014100338/article/details/79940886  


+ 解释一些内存分配担保机制？	  
新生代无法分配内存的时候，就把新生代转移到老年代，然后把新对象放入腾空的新生代。
https://www.jianshu.com/p/62c37dc7d638  
