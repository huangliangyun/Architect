#### 问题
+ Redis 使用场景？
+ Redis 为什么是单线程而且效率高？
+ aof 和 rdb 都有哪些优点？以及两者有何区别？
+ Redis的主从复制怎么做的？
+ Redis 线程模型？
+ Redis 数据结构？
+ Redis 内部如何实现排序的？
+ Redis 如何存放对象？
+ Redis 过期策略和缓存淘汰机制？
+ Redis 为什么是原子性，多个命令在并发中也是原子性吗？
+ RedisCluster 集群原理？
+ 缓存穿透，缓存击穿，缓存雪崩？
+ 缓存预热，缓存更新，缓存降级？



#### 答案
+ Redis 使用场景？  
token 令牌，分布式锁，短信验证码，缓存热点数据  


+ Redis 为什么是单线程而且效率高？  
多线程不一定比单线程效率高，多线程的本质就是CPU通过切换时间片执行不同的线程，看似多个线程一起执行，但是却承担线程上下文切换的代价。对于一个内存的系统来说，它没有上下文的切换就是效率最高的。而且底层采用了非阻塞IO多路复用机制，一个线程维护多个不同的客户端操作。 基于 epoll 模型，只对活跃的 socket 进行回调。


+ aof 和 rdb 都有哪些优点？以及两者有何区别？  
RBD 持久化可以手动触发，也可以自动触发，RBD 持久化的时候，会 fork 出一个与当前线程一模一样的线程，先将持久化数据写到一个文件中，持久化结束后，再用这个文件替换之前的文件，整个过程，主进程不进行任何磁盘 IO 操作；  
AOF是将Redis的操作以日志的方式追加写入文件，不记录读操作；  
AOF 数据丢失少，性能慢，不适宜于导入大量数据；  
RDB 如果宕机数据丢失多，性能高，适于导入大量数据；  


+ Redis的主从复制怎么做的？  
通过全量同步和命令传播完成。  
1）首先，从服务器会发送一个 sync 命令给主服务器要求全量同步  
2）当主服务器收到从服务器的 sync 命令时，会 fork 一个子进程后台执行 bgsave，生成 rdb 文件，然后将 rdb 文件发送给从服务器。  
3）从服务器收到 rdb 文件后载入自己的内存  
4）从服务器将 rdb 载入完成后，主服务器再将缓冲区所有写命令发送给从服务器   
5）从服务将主服务所有的命令载入内存从而实现命令的完整同步  
6）从服务下次需要同步数据时只需要发送自己的 offset 位置，进行增量同步即可  
7）命令传播是主服务器会把自己的写操作发送给从服务器执行，保证数据一致性。  


+ Redis 线程模型？  
1）Redis 底层采用 NIO 多路复用机制，对多个不同的连接实现 IO 复用，不仅支持非常好的并发，还保证了线程安全。 
2）多路 IO 复用的原理是使用 NIO 选择器，将多个不同的 Channel 交给我们的 Selector 进行管理。  
3）Linux 系统采用的是 epoll 实现事件驱动回调通知，不存在空轮询，只对活跃的 socket 连接实现主动回调，在性能上大大提升，时间复杂度为O(1)，支持上万连接。  
4）而 Window 操作系统采用的 select 实现轮询时间复杂度为 O(n),而且存在空轮询，效率非常低，而且对轮询的数据有限制，所以无法支持上万连接。  


+ Redis 数据结构？  
list：消息队列，分页  
set：去重  
sort set：排行榜  
hash  
string：计数功能，token，短信验证码  


+ Redis 内部如何实现排序的？  
sort 命令可以对列表类型，集合类型，有序集合类型进行排序，在 score 相同的情况下，使用字字典排序（字典排序是在首个字母相同的情况下，比较第二个字母）  


+ Redis 如何存放对象？   
	1）	使用json序列化存放，优点是可读性强，跨语言，缺点是明文不安全。  
	2）	以二进制方式进行存储，不可以跨语言，阅读性查，安全。  


+ Redis 过期策略和缓存淘汰机制？  
过期策略：定期删除+惰性删除（volatile-lru）  
Redis 默认每 100ms 随机抽查检查是否有过期的key，有过期的key就删除。  
缓存淘汰机制：6种  


+ Redis 为什么是原子性，多个命令在并发中也是原子性吗？  
因为 Redis 是单线程的，Redis 提供的API 都是原子操作，多个命令在并发中不一定是原子性，使用Redis事务。  


+ RedisCluster 集群原理？
1）在Redis集群模式中分为 16384 个卡槽  
2）在存入一个 key 的时候，对一个 key 使用 crc16 算法得到一个数字取余 16384，得到存放的卡槽位置。  
3）每个卡槽对应具体节点，这样就能将数据均摊存放到各个节点。  


+ 缓存预热，缓存更新，缓存降级？  
1）缓存预热：系统上线时，先将相关的缓存数据直接放到缓存系统，就可以避免用户请求的时候，先查数据库，再将数据缓存的问题。  
新页面，上线时手工刷新；项目启动的时候进行加载；定时刷新缓存。  
2）缓存更新：  
定时清理过期的缓存；用户进行请求的时候，先判断缓存是否过期，过期就重新得到数据并更新缓存。
3）缓存降级：访问量剧增，服务出现问题，仍然需要保证服务是可用的，系统可以根据一些关键数据进行自动降级，也可以设置开关进行人工降级。降级的目的是防止 redis 故障，当 redis 出现问题时，不去数据库查询，直接返回默认给用户。  


+ 缓存穿透，缓存击穿，缓存雪崩？